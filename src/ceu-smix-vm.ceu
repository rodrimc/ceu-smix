#include "media/media.ceu"

#define MEDIA    1
#define START    "start"
#define STOP     "stop"
#define PAUSE    "pause"
#define SEEK     "seek"
#define SET      "set"

native/pre do
##ifdef DEBUG
 ##undef DEBUG
 ##define DEBUG 1
##else
 ##define DEBUG 0
##endif

#define debug(fmt, ...) \
  do { if (DEBUG) fprintf(stderr, "%s:%d: " fmt, __FILE__, \
      __LINE__, __VA_ARGS__); } while (0)
end

native/nohold
  _debug,
;

event (void) smix_event;
vector [] byte event_condition = _;
vector [] byte event_source = _;

vector [] byte event_action = _;
vector [] byte event_target = _;

code/await
Smix_Media (var& IScene scene, vector&[] byte mediaid) -> void
do
  /* properties */
  vector[] byte src = [] .. [[ SMIX[@MEDIA][@mediaid].src or '' ]];
  var Region region = val Region (0, 0, 0, 0, 1);
  region.x      = [[ SMIX[@MEDIA][@mediaid].x or 0 ]];
  region.y      = [[ SMIX[@MEDIA][@mediaid].y or 0 ]];
  region.width  = [[ SMIX[@MEDIA][@mediaid].width or 0 ]];
  region.height = [[ SMIX[@MEDIA][@mediaid].height or 0 ]];
  region.z      = [[ SMIX[@MEDIA][@mediaid].z or 1 ]];

  var Media.Default media = val Media.Default ([] .. src, region);
  /*TODO: set other properties */

  _debug ("Smix_Media (%s)\n", &&mediaid[0]);
  do
    var& IPlayer player;
    watching Play (&scene, &media) -> (&player)
    do
      /* should we await the CM_PLAYER_START event? */
      outer.event_condition = [] .. START;
      outer.event_source    = [] .. mediaid;
      emit outer.smix_event;

      par do
        var uint id = await CM_PLAYER_START until (id == player.self);
        _debug ("%s has started\n", &&mediaid[0]);
      with
        /* TODO: */
      end
    end
  end

  outer.event_condition = [] .. STOP;
  outer.event_source    = [] .. mediaid;
  emit outer.smix_event;
end

pool [] Smix_Media media_pool;

code/await
Smix_Link (var& IScene scene, var int index) -> FOREVER
do
  vector [] byte condition = [] .. [[ SMIX[@index][1][1] ]];
  vector [] byte source    = [] .. [[ SMIX[@index][1][2] ]];

  vector [] byte action    = _;
  vector [] byte target    = _;

  _debug ("link: cond (%s) source (%s)\n",
              &&condition[0], &&source[0]);

  every outer.smix_event do
    if _strcmp (&&outer.event_condition[0], &&condition[0]) == 0 and
       _strcmp (&&outer.event_source[0], &&source[0]) == 0 then

      _debug ("link triggered: cond (%s) source (%s)\n",
                &&condition[0], &&source[0]);

      var int actions = [[ #SMIX[@index] - 1 ]];
      var int i;
      loop i in [1 -> actions ] do
        [[
           predicate = SMIX[@index][2][1]
           if (type (predicate) == 'function' ) then
             predicate = predicate ()
           end
        ]]

        var bool predicate = [[ predicate ]];

        if predicate then
          action = [] .. [[ SMIX[@index][@i + 1][2] ]];
          target = [] .. [[ SMIX[@index][@i + 1][3] ]];

          if _strcmp (&&action[0], START) == 0 then
            spawn Smix_Media (&scene, &target) in outer.media_pool;
          end
        end
      end
    end
  end
end

pool [] Smix_Link links_pool;

/* load SMIX file */
vector [] byte file = [] .. "examples/example1.lua";
[[
  SMIX = dofile (@file)

  if SMIX[@MEDIA].lambda == nil then
    SMIX[@MEDIA].lambda = {width = 640, height = 480}
  end
]]

var int width   = [[ SMIX[MEDIA].lambda.width ]];
var int height  = [[ SMIX[MEDIA].lambda.height ]];

var& IScene scene;
watching Scene (Size(width, height)) -> (&scene) do
  /* spawn links */
  var int links = [[ #SMIX - 1 ]];
  var int i;
  loop i in [1 -> links] do
    spawn Smix_Link (&scene, i + 1) in links_pool;
  end

  /* start application */
  event_condition = [] .. START;
  event_source    = [] .. "lambda";
  emit smix_event;

  await FOREVER;
end

escape 0;
